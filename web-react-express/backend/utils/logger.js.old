const fs = require('fs');
const path = require('path');
const { format, subDays } = require('date-fns');
const { promisify } = require('util');

// 转换为Promise API
const statAsync = promisify(fs.stat);
const readdirAsync = promisify(fs.readdir);
const unlinkAsync = promisify(fs.unlink);
const mkdirAsync = promisify(fs.mkdir);
const writeFileAsync = promisify(fs.writeFile);

const LOG_ROOT = path.join(__dirname, '../python/logs');
const MAX_LOG_DAYS = 7;
const ENCODING = 'utf8';

class Logger {
  constructor() {
    this.ensureLogDir().catch(console.error);
  }

  /**
   * 确保日志目录存在
   */
  async ensureLogDir() {
    try {
      await mkdirAsync(LOG_ROOT, { recursive: true });
    } catch (err) {
      console.error('无法创建日志目录:', err);
      throw err;
    }
  }

  /**
   * 生成带时间戳的日志文件名
   */
  generateLogFilename() {
    const timestamp = format(new Date(), 'yyyyMMdd_HHmmss');
    return `error_${timestamp}.log`;
  }

  /**
   * 写入错误日志（主入口）
   * @param {string|Object} errorData 错误信息
   * @returns {Promise<string|null>} 日志文件路径
   */
  async createErrorLog(errorData) {
    try {
      await this.rotateLogs();
      
      const filename = this.generateLogFilename();
      const logPath = path.join(LOG_ROOT, filename);
      const content = this.formatLogContent(errorData);

      await writeFileAsync(logPath, content, { encoding: ENCODING });
      return logPath;
    } catch (err) {
      console.error('写入日志失败:', err);
      return null;
    }
  }

  /**
   * 格式化日志内容
   */
  formatLogContent(errorData) {
    const timestamp = format(new Date(), 'yyyy-MM-dd HH:mm:ss.SSS');
    let content = `[${timestamp}] ERROR\n`;

    if (errorData instanceof Error) {
      content += `Message: ${errorData.message}\n`;
      content += `Stack: ${errorData.stack}\n`;
    } else if (typeof errorData === 'object') {
      content += JSON.stringify(errorData, null, 2);
    } else {
      content += String(errorData);
    }

    return content + '\n\n';
  }

  /**
   * 日志轮转清理
   */
  async rotateLogs() {
    try {
      const files = await readdirAsync(LOG_ROOT);
      const cutoffDate = subDays(new Date(), MAX_LOG_DAYS);

      for (const file of files) {
        if (!file.startsWith('error_')) continue;

        const filePath = path.join(LOG_ROOT, file);
        const stats = await statAsync(filePath);

        if (stats.birthtime < cutoffDate) {
          await unlinkAsync(filePath);
          console.log(`清理旧日志: ${file}`);
        }
      }
    } catch (err) {
      console.error('日志轮转失败:', err);
    }
  }

  /**
   * 获取相对路径（用于API响应）
   */
  getRelativePath(fullPath) {
    return path.relative(process.cwd(), fullPath);
  }
}

// 单例实例
const loggerInstance = new Logger();

// 修改导出方式，确保返回字符串
module.exports = {
  createErrorLog: async (error) => {
    try {
      const fullPath = await loggerInstance.createErrorLog(error);
      return fullPath ? path.relative(process.cwd(), fullPath) : null;
    } catch (err) {
      console.error('日志创建失败:', err);
      return null;
    }
  }
};

